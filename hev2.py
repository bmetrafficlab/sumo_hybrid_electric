import traci
import math
import xml.etree.ElementTree as ET
import numpy as np
import matplotlib.pyplot as plt


# <-------------------- USER SETTINGS -------------------->
sumo_cfg = "m1m7_2023Oct_Mondays_8.sumocfg"
netFile_path = "M1-M7.net.xml"

# Ratio of vehicles with mode switching
vehicle_ratio = 50

# Define thresholds for mode switching
SPEED_THRESHOLD_FOR_ELECTRIC = 32  # km/h
SPEED_THRESHOLD_FOR_PETROL = 100   # km/h
POWER_THRESHOLD_FOR_ELECTRIC = 10  # kW
POWER_THRESHOLD_FOR_PETROL = 120   # kW
# <-------------------- END OF USER SETTINGS -------------------->


# <---------CONSTANTS FOR 2010 PHEV TOYOTA PRIUS----------------->
vehicle_mass = 1460  # in kg (avg human weight + weight of prius)
gravitational_constant = 9.81  # in m/s^2
rolling_resistance_coefficient = 0.2  # for dry asphalt
air_density = 1.293  # in kg/m^3
drag_coefficient = 0.23  # for a 2010 Toyota Prius
frontal_area = 2.22  # in m^2 (converted from 23.9 square feet)
regeneration_efficiency = 0.462  # 46.2% regen efficiency


eta_batt = 0.95  # Average battery efficiency (90% to 95%)
eta_pe = 0.98    # Average power electronics efficiency (96% to 99%)
eta_mot = 0.96   # Average electric motor efficiency (90% to 97%)
eta_pt = 0.98    # Mechanical efficiency of the powertrain


def parse_net_file(net_file_path):
    """
    Parse the network file to extract lane shapes.

    :param net_file_path: Path to the network XML file.
    :return: Dictionary mapping lane IDs to their start and end points.
    """
    tree = ET.parse(net_file_path)
    root = tree.getroot()

    lane_shapes = {}

    for lane in root.findall('.//lane'):
        lane_id = lane.get('id')
        shape = lane.get('shape')

        # Convert the shape string into a list of (x,y) tuples
        points = [tuple(map(float, point.split(','))) for point in shape.split()]

        # Store the start and end points
        if points:
            lane_shapes[lane_id] = {'start': points[0], 'end': points[-1]}

    return lane_shapes


def calculate_instantaneous_power(speed, acceleration, theta):

    """
    Calculate the instantaneous power needed or regenerated by a vehicle at a given speed, acceleration,
    and road elevation.

    :param speed: Speed of the vehicle in km/h.
    :param acceleration: Acceleration of the vehicle in m/s^2.
    :param theta: Road elevation in radians.
    :return: Total instantaneous power in watts.
    """

    # Rolling Resistance Power
    rolling_resistance_power = rolling_resistance_coefficient * vehicle_mass * gravitational_constant * math.cos(theta) * speed

    # Gradient Resistance Power
    gradient_resistance_power = vehicle_mass * gravitational_constant * math.sin(theta) * speed

    # Aerodynamic Drag Power
    aerodynamic_drag_power = 0.5 * air_density * drag_coefficient * frontal_area * speed ** 3

    # Acceleration Power
    if acceleration > 0:
        positive_acceleration = acceleration
    else:
        positive_acceleration = 0
    acceleration_power = vehicle_mass * positive_acceleration * speed

    # Regeneration Power
    if acceleration < 0:
        negative_acceleration = acceleration
        regeneration_power = vehicle_mass * negative_acceleration * speed * regeneration_efficiency
    else:
        regeneration_power = 0

    # Summing all the power components.
    total_tractive_power = rolling_resistance_power + gradient_resistance_power + aerodynamic_drag_power + acceleration_power

    total_instantaneous_power = (total_tractive_power / (eta_batt * eta_pe * eta_mot * eta_pt)) + (regeneration_power * eta_batt * eta_pe * eta_mot * eta_pt)

    return total_instantaneous_power


def run_simulation(mode_switch_ratio):
    """
    Runs the traffic simulation with mode-switching capabilities and collect metrics.

    The simulation assigns vehicles with mode-switch capabilities based on a specified ratio and collects various
    performance metrics, such as fuel consumption, PMx emissions, electricity consumption, CO2 emissions, and speed.

    Mode-switch logic determines whether a vehicle should operate in electric or petrol mode based on its speed and
    power demand. If a vehicle's speed is within the electric mode threshold and the power demand exceeds the threshold
    for electric power, the vehicle switches to electric mode. Conversely, if the vehicle's speed exceeds the petrol
    mode threshold and the power demand is above the petrol power threshold, it switches back to petrol mode.

    :param mode_switch_ratio: Percentage of vehicles that will have mode-switching capabilities.
    :return: A tuple of two dictionaries containing mode-switch metrics and regular vehicle metrics.
    """
    lane_shapes = parse_net_file(netFile_path)
    traci.start(["sumo-gui", "-c", sumo_cfg, "--start"])

    period_time = 300
    step_time = 0.5

    assigned_vehicles = set()
    mode_switch_vehicles = set()
    total_vehicles_processed = 0

    # Dictionary to track the current mode of the vehicles
    vehicle_modes = {}

    mode_switch_metrics = {
        'fuel_consumption': [],
        'pmx': [],
        'co2': [],
        'nox': [],
        'speed': []
    }

    regular_vehicle_metrics = {
        'fuel_consumption': [],
        'pmx': [],
        'co2': [],
        'nox': [],
        'speed': []
    }

    for i in range(int(period_time / step_time)):
        traci.simulationStep()
        current_vehicle_ids = set(traci.vehicle.getIDList())

        for vehicle_id in current_vehicle_ids:
            type_id = traci.vehicle.getTypeID(vehicle_id)

            if vehicle_id not in assigned_vehicles:
                total_vehicles_processed += 1
                # Assigns vehicles to mode switch group based on the ratio
                if (len(mode_switch_vehicles) / total_vehicles_processed) < (mode_switch_ratio / 100):
                    mode_switch_vehicles.add(vehicle_id)
                assigned_vehicles.add(vehicle_id)

            speed_in_km = math.ceil(traci.vehicle.getSpeed(vehicle_id) * 3.6)  # Convert m/s to km/h
            acceleration = traci.vehicle.getAcceleration(vehicle_id)

            lane_id = traci.vehicle.getLaneID(vehicle_id)

            # Calculate Slope
            # Check if the lane ID is in lane_shapes dictionary
            if lane_id in lane_shapes:
                z_start = lane_shapes[lane_id]['start'][2]
                z_end = lane_shapes[lane_id]['end'][2]

                change_in_z = z_end - z_start

                lane_length = traci.lane.getLength(lane_id)

                alpha_radians = math.atan(change_in_z / lane_length)

                theta = alpha_radians

                total_instantaneous_power = calculate_instantaneous_power(speed_in_km, acceleration, theta)

                instantaneous_power_in_kw = total_instantaneous_power / 1000  # Converts power to kW

                # Mode switching logic
                if vehicle_id in mode_switch_vehicles:
                    # Check if we need to switch to electric mode
                    if type_id == "petrol_mode" and SPEED_THRESHOLD_FOR_ELECTRIC < speed_in_km <= \
                            SPEED_THRESHOLD_FOR_PETROL and instantaneous_power_in_kw > POWER_THRESHOLD_FOR_ELECTRIC:
                        traci.vehicle.setType(vehicle_id, "electric_mode")
                        vehicle_modes[vehicle_id] = "electric_mode"
                        # print(f"Vehicle {vehicle_id} at {speed_in_km}km/h has switched to electric mode.")

                    # Check if we need to switch back to petrol mode
                    elif type_id == "electric_mode" and speed_in_km > SPEED_THRESHOLD_FOR_PETROL and \
                            instantaneous_power_in_kw > POWER_THRESHOLD_FOR_PETROL:
                        traci.vehicle.setType(vehicle_id, "petrol_mode")
                        vehicle_modes[vehicle_id] = "petrol_mode"
                        # print(f"Vehicle {vehicle_id} at {speed_in_km}km/h has switched back to petrol mode.")

                    mode_switch_metrics['fuel_consumption'].append(traci.vehicle.getFuelConsumption(vehicle_id))
                    mode_switch_metrics['pmx'].append(traci.vehicle.getPMxEmission(vehicle_id))
                    mode_switch_metrics['nox'].append(traci.vehicle.getNOxEmission(vehicle_id))
                    mode_switch_metrics['co2'].append(traci.vehicle.getCO2Emission(vehicle_id))
                    mode_switch_metrics['speed'].append(speed_in_km)

                else:
                    # No mode switching; just append metrics to regular_vehicle_metrics
                    regular_vehicle_metrics['fuel_consumption'].append(traci.vehicle.getFuelConsumption(vehicle_id))
                    regular_vehicle_metrics['pmx'].append(traci.vehicle.getPMxEmission(vehicle_id))
                    regular_vehicle_metrics['nox'].append(traci.vehicle.getNOxEmission(vehicle_id))
                    regular_vehicle_metrics['co2'].append(traci.vehicle.getCO2Emission(vehicle_id))
                    regular_vehicle_metrics['speed'].append(speed_in_km)

    traci.close()

    return mode_switch_metrics, regular_vehicle_metrics


def plot_grouped_bar_chart(mode_switch_metrics, regular_vehicle_metrics):
    """
    Plot grouped bar charts comparing emissions and fuel consumption for vehicles with and
    without mode-switch capabilities.

    :param mode_switch_metrics: Dictionary containing aggregated metrics for mode-switch vehicles.
    :param regular_vehicle_metrics: Dictionary containing aggregated metrics for regular vehicles.
    """
    # Sum of emissions without mode-switch logic
    sum_CO2 = sum(regular_vehicle_metrics['co2'])
    sum_PMx = sum(regular_vehicle_metrics['pmx'])
    sum_NOx = sum(regular_vehicle_metrics['nox'])
    sum_fuel = sum(regular_vehicle_metrics['fuel_consumption'])

    # Print cumulative sum
    print("------------------------------")
    print("Cumulative emissions for vehicles without mode-switch logic:")
    print("Sum of CO2:", sum_CO2, "mg")
    print("Sum of PMx:", sum_PMx, "mg")
    print("Sum of NOx:", sum_NOx, "mg")
    print("Sum of Fuel Consumption:", sum_fuel, "mg")

    # Sum of emissions with mode-switch logic
    sum_CO2_mode_switch = sum(mode_switch_metrics['co2'])
    sum_PMx_mode_switch = sum(mode_switch_metrics['pmx'])
    sum_NOx_mode_switch = sum(mode_switch_metrics['nox'])
    sum_fuel_mode_switch = sum(mode_switch_metrics['fuel_consumption'])

    # Print cumulative sum
    print("------------------------------")
    print("Cumulative emissions for vehicles with mode-switch logic:")
    print("Sum of CO2:", sum_CO2_mode_switch, "mg")
    print("Sum of PMx:", sum_PMx_mode_switch, "mg")
    print("Sum of NOx:", sum_NOx_mode_switch, "mg")
    print("Sum of Fuel Consumption:", sum_fuel_mode_switch, "mg")

    # Calculating the absolute differences
    diff_CO2 = abs(sum_CO2_mode_switch - sum_CO2)
    diff_PMx = abs(sum_PMx_mode_switch - sum_PMx)
    diff_NOx = abs(sum_NOx_mode_switch - sum_NOx)
    diff_fuel = abs(sum_fuel_mode_switch - sum_fuel)

    # Print Absolute differences
    print("------------------------------")
    print("Absolute differences:")
    print("Difference of CO2:", diff_CO2, "mg")
    print("Difference of PMx:", diff_PMx, "mg")
    print("Difference of NOx:", diff_NOx, "mg")
    print("Difference of Fuel Consumption:", diff_fuel, "mg")

    metrics = ['co2', 'nox', 'pmx', 'fuel_consumption']
    mode_switch_sums = [sum(mode_switch_metrics[metric]) for metric in metrics]
    regular_sums = [sum(regular_vehicle_metrics[metric]) for metric in metrics]

    # Define the label locations and the width of the bars
    x = np.arange(len(metrics))  # the label locations
    width = 0.35  # the width of the bars

    fig, ax = plt.subplots()
    rects1 = ax.bar(x - width/2, mode_switch_sums, width, label='Vehicles with Mode Switch')
    rects2 = ax.bar(x + width/2, regular_sums, width, label='Vehicles without Mode Switch')

    ax.set_ylabel('Emissions/Fuel Consumption (mg)')
    ax.set_title('Cumulative Emissions')
    ax.set_xticks(x)
    ax.set_xticklabels(['CO2', 'NOx', 'PMx', 'Fuel Consumption'])
    ax.legend()

    # Plotting the absolute difference bar chart
    fig_diff, ax_diff = plt.subplots()
    diffs = [diff_CO2, diff_NOx, diff_PMx, diff_fuel]
    ax_diff.bar(metrics, diffs, color='skyblue')
    ax_diff.set_ylabel('Absolute Difference in Emissions/Fuel Consumption (mg)')
    ax_diff.set_title('Absolute Difference Between Mode-Switch and Regular Vehicles')
    ax_diff.set_xticks(x)
    ax_diff.set_xticklabels(metrics)

    # Text label
    def autolabel(rects):
        for rect in rects:
            height = rect.get_height()
            ax.annotate('{:.2f}'.format(height),
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom',
                        rotation=-20)

    autolabel(rects1)
    autolabel(rects2)

    fig.tight_layout()

    plt.show()


mode_switch_metrics, regular_vehicle_metrics = run_simulation(vehicle_ratio)
plot_grouped_bar_chart(mode_switch_metrics, regular_vehicle_metrics)

